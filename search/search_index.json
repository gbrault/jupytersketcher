{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jupyter Sketcher Documentation Home Page of jupytersketcher project Problem solved When you need to solve a mechanical problem, sooner or later you are going to sketch a figure to capture problem's parameters and variables. The better documented, the easier the problem is to resolve for the designer, and the easier it is for others to understand how it is actually solved. What if you could capture this in the program solving the problem and use it as a repository for all definitions and physical variables? This is what jupytersketcher (name of pysketcher module) is proposing to solve. Of course, this makes even more sense when using Jupyter notebooks, because as a sketch not only the image of the solved problem can be displayed, but the dictionary of all variables processed in the notebook for solving physics is used to draw the image and at the same time to solve the equations of motion. jupytersketcher is another small step to help building reusable science. Getting Started You can use the binder link in jupytersketcher Github to see some experiments with pysketcher. pysketcher features Drawing sketches on a matplotlib widget for Jupyter Notebook server or Lab Defining a yaml based \"grammar\" to define sketches and simplify reuse Animating sketches within Jupyter notebooks Main benefit With Pysketcher for Jupyter mechanical notebooks, you get a single copy of the description of the problem which is as well a space to simulate the system behaviour","title":"Home"},{"location":"#welcome-to-jupyter-sketcher-documentation","text":"Home Page of jupytersketcher project","title":"Welcome to Jupyter Sketcher Documentation"},{"location":"#problem-solved","text":"When you need to solve a mechanical problem, sooner or later you are going to sketch a figure to capture problem's parameters and variables. The better documented, the easier the problem is to resolve for the designer, and the easier it is for others to understand how it is actually solved. What if you could capture this in the program solving the problem and use it as a repository for all definitions and physical variables? This is what jupytersketcher (name of pysketcher module) is proposing to solve. Of course, this makes even more sense when using Jupyter notebooks, because as a sketch not only the image of the solved problem can be displayed, but the dictionary of all variables processed in the notebook for solving physics is used to draw the image and at the same time to solve the equations of motion. jupytersketcher is another small step to help building reusable science.","title":"Problem solved"},{"location":"#getting-started","text":"You can use the binder link in jupytersketcher Github to see some experiments with pysketcher.","title":"Getting Started"},{"location":"#pysketcher-features","text":"Drawing sketches on a matplotlib widget for Jupyter Notebook server or Lab Defining a yaml based \"grammar\" to define sketches and simplify reuse Animating sketches within Jupyter notebooks","title":"pysketcher features"},{"location":"#main-benefit","text":"With Pysketcher for Jupyter mechanical notebooks, you get a single copy of the description of the problem which is as well a space to simulate the system behaviour","title":"Main benefit"},{"location":"about/","text":"In summer 2020 I discovered Pysketcher as I was looking for a way to create Physics sketches for both design and simulation. My second requirement is to have sketches available in Jupyter notebooks (Lab or notebook server) Pysketch was developped in 2012 by Hans Petter Langtangen , see it in GitHub . At that time, Jupyter was emerging and Pysketch was developped as a standalone application. I just need to upgrade it to make it compatible with Jupyter: This is the inception of Jupyter Sketch project! A sketch capturing the \"dry friction case\" How it is structured: the composition hierarchy Built with mkdocs 1.1.0 mkdocs-material 5.4.0","title":"About"},{"location":"reference/","text":"List of Shapes Code to display shapes Line : defines a line providing start and end point Rectangle : defines a rectangle providing bottom left corner, x dimension, y dimension Triangle : defines a triangle providing three corner Circle : defines a circle proving center and radius Distance with text : defines a sizing mark with a label Text : defines a given text positionned at the provided point Cross : defines a cross positionned at the provided point Axis : defines an axis at the given point with a given label Arc : defines an Arc providing a center point, a radius, a starting angle and an angle (rotates clock-wise) Arc_wText : defines an arc with text positionned left (moving clock-wise) of arc half-way Arrow1 : defines a line with arrow(s) given starting and ending point and arrow termination(s) ->, \\<->, \\<- Force : defines an Indication of a force by an arrow and a text (symbol) Wall : defines an hached box given starting, ending point and thickness, filled with a pattern Line home Defines a line providing start and end point Yaml A: point(-5,-5) B: point(5,5) line: Line(A,B) Python A = point(-5,-5) B = point(5,5) line = Line(A,B) Rectangle home Defines a rectangle providing bottom left corner, x dimension, y dimension Yaml L: 8 h: 5 p: point(-(L/2),-(h/2)) rectangle: Rectangle(p,L,h) Python L = 8 h = 5 p = point(-(L/2),-(h/2)) rectangle = Rectangle(p,L,h) Circle home Defines a circle proving center and radius Yaml circle: Circle(point(0,0),5) Python circle = Circle(point(0,0),5) Triangle home Defines a triangle providing three corner Yaml L: 3.0 W: 4.0 triangle: Triangle(p1=(W/2,0), p2=(3*W/2,W/2), p3=(4*W/5.,L)) Python L = 3.0 W = 4.0 triangle = Triangle(p1=(W/2,0), p2=(3*W/2,W/2), p3=(4*W/5.,L)) Distance with text home Defines a sizing mark with a label Yaml fontsize: 14 t: r'$ 2\\pi R^2 $' # sample text dwt: Distance_wText((-4,0), (8, 5), t, fontsize) Python fontsize=14 t = r'$ 2\\pi R^2 $' # sample text dwt = Distance_wText((-4,0), (8, 5), t, fontsize) Text home Defines a given text positionned at the provided point Yaml text: Text(r'$c$', point(0,0)) Python text = Text(r'$c$', point(0,0)) Cross home Defines a cross positionned at the provided point Yaml cross: Cross(point(0,0)) Python cross = Cross(point(1,0)) Axis home Defines an axis at the given point with a given label Yaml axis: Axis((0,0), 5, 'x', rotation_angle=0) Python axis = Axis((0,0), 5, 'x', rotation_angle=0) Arc home Defines an Arc providing a center point, a radius, a starting angle and an angle (rotates clock-wise) Yaml center: point(0,0) radius: 1 angle: 120 start_angle: 180-angle arc_angle: angle arc: Arc(center, radius, start_angle, arc_angle) Python center = point(0,0) radius = 1 angle = 120 start_angle = 180-angle arc_angle = angle arc = Arc(center, radius, start_angle, arc_angle) Arc_wText home Defines an arc with text positionned left (moving clock-wise) of arc half-way Yaml center: point(0,0) radius: 1 angle: 120 start_angle: 180-angle arc_angle: angle arc_wtxt: \"Arc_wText(r'$<bslash>theta$', center, radius, start_angle, arc_angle)\" Python center = point(0,0) radius = 1 angle = 120 start_angle = 180-angle arc_angle = angle arc_wtxt = Arc_wText(r'$\\theta$', center, radius, start_angle, arc_angle) Arrow1 home defines a line with arrow(s) given starting and ending point and arrow termination(s) ->, \\<->, \\<- Yaml start: point(0,0) end: point(5,5) arrow1: Arrow1(start, end, style='<->') Python start = point(0,0) end = point(5,5) arrow1 = Arrow1(start, end, style='<->') Force home defines an Indication of a force by an arrow and a text (symbol) Yaml x: 0 y: 0 contact: point(x, y) vector: point(-3,-5) force: Force(contact - vector, contact, r'$Force$', text_pos='start') Python x = 0 y = 0 contact = point(x, y) vector = point(-3,-5) force = Force(contact - vector, contact, r'$Force$', text_pos='start') Wall home defines an hached box given starting, ending point and thickness, filled with a pattern Yaml theta: 30 L: 8 B: point(L-4,-2) # wall right end A: point(-4,tan(radians(theta))*L-2) # wall left end wall: formula: Wall(x=[A[0], B[0]], y=[A[1], B[1]], thickness=-0.5,transparent=False) style: linecolor: black Python theta = 30 L = 8 B = point(L-4,-2) # wall right end A = point(-4,tan(radians(theta))*L-2) # wall left end wall= Wall(x=[A[0], B[0]], y=[A[1], B[1]], thickness=-0.5,transparent=False) wall.set_linecolor('black') Code to display the above defined shapes home In order to display the various shapes, use the following code in a jupyter notebook [1]: %matplotlib widget [2]: from pysketcher import * [3]: from math import tan, radians, sin, cos # needed for python code [4]: drawing_tool.set_coordinate_system(xmin=-10, xmax=10,ymin=-10, ymax=10,axis=True) [5]: drawing_tool.mpl.gcf().canvas for Yaml, you need to add those extra steps head = \"\"\"\\ libraries: [\"from math import tan, radians, sin, cos\",\"from pysketcher import *\"] myfig={} sketchParse(head,myfig) The above code initialize myfig sketch space loading into it libraries references so samples can use tan, radians, si, cos and all the objects defined in pysketcher (the module name of jupytersketcher): this is used by the yaml definition of shapes Yaml myfig={} sketch=\"\"\" # put here the yaml 'object' definition \"\"\" drawing_tool.erase() sketchParse(sketch,myfig) # replace 'object' by the actual one d = myfig['object'].draw() drawing_tool.display() Python drawing_tool.erase() # put the code of the object case here # replace object by the actual name line, rectangle, circle... object.draw() drawing_tool.display()","title":"Reference"},{"location":"reference/#list-of-shapes","text":"Code to display shapes Line : defines a line providing start and end point Rectangle : defines a rectangle providing bottom left corner, x dimension, y dimension Triangle : defines a triangle providing three corner Circle : defines a circle proving center and radius Distance with text : defines a sizing mark with a label Text : defines a given text positionned at the provided point Cross : defines a cross positionned at the provided point Axis : defines an axis at the given point with a given label Arc : defines an Arc providing a center point, a radius, a starting angle and an angle (rotates clock-wise) Arc_wText : defines an arc with text positionned left (moving clock-wise) of arc half-way Arrow1 : defines a line with arrow(s) given starting and ending point and arrow termination(s) ->, \\<->, \\<- Force : defines an Indication of a force by an arrow and a text (symbol) Wall : defines an hached box given starting, ending point and thickness, filled with a pattern","title":"List of Shapes"},{"location":"reference/#line","text":"home Defines a line providing start and end point","title":"Line"},{"location":"reference/#yaml","text":"A: point(-5,-5) B: point(5,5) line: Line(A,B)","title":"Yaml"},{"location":"reference/#python","text":"A = point(-5,-5) B = point(5,5) line = Line(A,B)","title":"Python"},{"location":"reference/#rectangle","text":"home Defines a rectangle providing bottom left corner, x dimension, y dimension","title":"Rectangle"},{"location":"reference/#yaml_1","text":"L: 8 h: 5 p: point(-(L/2),-(h/2)) rectangle: Rectangle(p,L,h)","title":"Yaml"},{"location":"reference/#python_1","text":"L = 8 h = 5 p = point(-(L/2),-(h/2)) rectangle = Rectangle(p,L,h)","title":"Python"},{"location":"reference/#circle","text":"home Defines a circle proving center and radius","title":"Circle"},{"location":"reference/#yaml_2","text":"circle: Circle(point(0,0),5)","title":"Yaml"},{"location":"reference/#python_2","text":"circle = Circle(point(0,0),5)","title":"Python"},{"location":"reference/#triangle","text":"home Defines a triangle providing three corner","title":"Triangle"},{"location":"reference/#yaml_3","text":"L: 3.0 W: 4.0 triangle: Triangle(p1=(W/2,0), p2=(3*W/2,W/2), p3=(4*W/5.,L))","title":"Yaml"},{"location":"reference/#python_3","text":"L = 3.0 W = 4.0 triangle = Triangle(p1=(W/2,0), p2=(3*W/2,W/2), p3=(4*W/5.,L))","title":"Python"},{"location":"reference/#distance-with-text","text":"home Defines a sizing mark with a label","title":"Distance with text"},{"location":"reference/#yaml_4","text":"fontsize: 14 t: r'$ 2\\pi R^2 $' # sample text dwt: Distance_wText((-4,0), (8, 5), t, fontsize)","title":"Yaml"},{"location":"reference/#python_4","text":"fontsize=14 t = r'$ 2\\pi R^2 $' # sample text dwt = Distance_wText((-4,0), (8, 5), t, fontsize)","title":"Python"},{"location":"reference/#text","text":"home Defines a given text positionned at the provided point","title":"Text"},{"location":"reference/#yaml_5","text":"text: Text(r'$c$', point(0,0))","title":"Yaml"},{"location":"reference/#python_5","text":"text = Text(r'$c$', point(0,0))","title":"Python"},{"location":"reference/#cross","text":"home Defines a cross positionned at the provided point","title":"Cross"},{"location":"reference/#yaml_6","text":"cross: Cross(point(0,0))","title":"Yaml"},{"location":"reference/#python_6","text":"cross = Cross(point(1,0))","title":"Python"},{"location":"reference/#axis","text":"home Defines an axis at the given point with a given label","title":"Axis"},{"location":"reference/#yaml_7","text":"axis: Axis((0,0), 5, 'x', rotation_angle=0)","title":"Yaml"},{"location":"reference/#python_7","text":"axis = Axis((0,0), 5, 'x', rotation_angle=0)","title":"Python"},{"location":"reference/#arc","text":"home Defines an Arc providing a center point, a radius, a starting angle and an angle (rotates clock-wise)","title":"Arc"},{"location":"reference/#yaml_8","text":"center: point(0,0) radius: 1 angle: 120 start_angle: 180-angle arc_angle: angle arc: Arc(center, radius, start_angle, arc_angle)","title":"Yaml"},{"location":"reference/#python_8","text":"center = point(0,0) radius = 1 angle = 120 start_angle = 180-angle arc_angle = angle arc = Arc(center, radius, start_angle, arc_angle)","title":"Python"},{"location":"reference/#arc_wtext","text":"home Defines an arc with text positionned left (moving clock-wise) of arc half-way","title":"Arc_wText"},{"location":"reference/#yaml_9","text":"center: point(0,0) radius: 1 angle: 120 start_angle: 180-angle arc_angle: angle arc_wtxt: \"Arc_wText(r'$<bslash>theta$', center, radius, start_angle, arc_angle)\"","title":"Yaml"},{"location":"reference/#python_9","text":"center = point(0,0) radius = 1 angle = 120 start_angle = 180-angle arc_angle = angle arc_wtxt = Arc_wText(r'$\\theta$', center, radius, start_angle, arc_angle)","title":"Python"},{"location":"reference/#arrow1","text":"home defines a line with arrow(s) given starting and ending point and arrow termination(s) ->, \\<->, \\<-","title":"Arrow1"},{"location":"reference/#yaml_10","text":"start: point(0,0) end: point(5,5) arrow1: Arrow1(start, end, style='<->')","title":"Yaml"},{"location":"reference/#python_10","text":"start = point(0,0) end = point(5,5) arrow1 = Arrow1(start, end, style='<->')","title":"Python"},{"location":"reference/#force","text":"home defines an Indication of a force by an arrow and a text (symbol)","title":"Force"},{"location":"reference/#yaml_11","text":"x: 0 y: 0 contact: point(x, y) vector: point(-3,-5) force: Force(contact - vector, contact, r'$Force$', text_pos='start')","title":"Yaml"},{"location":"reference/#python_11","text":"x = 0 y = 0 contact = point(x, y) vector = point(-3,-5) force = Force(contact - vector, contact, r'$Force$', text_pos='start')","title":"Python"},{"location":"reference/#wall","text":"home defines an hached box given starting, ending point and thickness, filled with a pattern","title":"Wall"},{"location":"reference/#yaml_12","text":"theta: 30 L: 8 B: point(L-4,-2) # wall right end A: point(-4,tan(radians(theta))*L-2) # wall left end wall: formula: Wall(x=[A[0], B[0]], y=[A[1], B[1]], thickness=-0.5,transparent=False) style: linecolor: black","title":"Yaml"},{"location":"reference/#python_12","text":"theta = 30 L = 8 B = point(L-4,-2) # wall right end A = point(-4,tan(radians(theta))*L-2) # wall left end wall= Wall(x=[A[0], B[0]], y=[A[1], B[1]], thickness=-0.5,transparent=False) wall.set_linecolor('black')","title":"Python"},{"location":"reference/#code-to-display-the-above-defined-shapes","text":"home In order to display the various shapes, use the following code in a jupyter notebook [1]: %matplotlib widget [2]: from pysketcher import * [3]: from math import tan, radians, sin, cos # needed for python code [4]: drawing_tool.set_coordinate_system(xmin=-10, xmax=10,ymin=-10, ymax=10,axis=True) [5]: drawing_tool.mpl.gcf().canvas for Yaml, you need to add those extra steps head = \"\"\"\\ libraries: [\"from math import tan, radians, sin, cos\",\"from pysketcher import *\"] myfig={} sketchParse(head,myfig) The above code initialize myfig sketch space loading into it libraries references so samples can use tan, radians, si, cos and all the objects defined in pysketcher (the module name of jupytersketcher): this is used by the yaml definition of shapes","title":"Code to display the above defined shapes"},{"location":"reference/#yaml_13","text":"myfig={} sketch=\"\"\" # put here the yaml 'object' definition \"\"\" drawing_tool.erase() sketchParse(sketch,myfig) # replace 'object' by the actual one d = myfig['object'].draw() drawing_tool.display()","title":"Yaml"},{"location":"reference/#python_13","text":"drawing_tool.erase() # put the code of the object case here # replace object by the actual name line, rectangle, circle... object.draw() drawing_tool.display()","title":"Python"},{"location":"sketcher/","text":"A language to describe a sketch Pysketcher initial version HPL Pysketcher enable sketch definition in python. HPL is showing the hierachical nature of sketches. This is implemented via the Composition function. One can further grasp this using the graphviz_dot function applied to discover the composition herarchy implemented as a graphviz image see The hierarchy of the \"friction\" main object at the end of this page. Due to the hierarchical nature of sketches, it is quite straightforward to think about using yaml as the syntax for defining a sketch. Benefits are the following: Leaner sketch writing as only data relevant to the context needs to be defined A more straightforward reading for the same reason A more robust sketch definition The same set of rules is applied to generate a sketch No further python idiom is be intermingled as opposed to the case of python defined sketches Of course, data defined versus program defined there is no winner, it's just a matter of context Example This example provides the yaml content to define the Dry Friction case The final sketch An inclined plan (the A-B edge) supports a blue rectangle which is dragged down by gravity. The plan makes an angle \\theta \\theta with the ground level. Sketch implementation notebook includes a controller enabling the \\theta \\theta angle to change. The whole plan, including the body, can rotate arround point B. Support files The example we are developing now is based upon the \"Dry Friction mockup\" notebook the rendered html version of the notbook can be viewed here the notebook can be download here The yaml definition Sketcher language is defined as a yaml compliant file or string. The yaml file is a dictionnary of \"objects\". Objects can be regular python objects or sketcher objects. A skertcher object is composed as follow: a formula : it's a leaf object, like Rectangle, Circle, Line etc or a composition a style list : line or fill colors, line stroke... declared as a yaml hierarchy a transformation list : the defined object can be transformed using sketcher transformation: translation, rotation... As a general rule, a new object suppose all parameters to be defined before they are used to construct it. For example, you can create a circle if the center and the radius have been defined earlier in the file. The general layout of a sketcher file is as follow: Libraries, Construction Variables, Frame declaration of the libraries used by the objects further declared: at least pysketcher is mandatory various global variable which encompass the \"Construction\" variables which define the object main physical dimensions, positions... some \"actions\" corresponding to executable python sentences One mandatory action is the setting of the drawing frame (drawing_tool.set_coordinate_system): it must be declared before any other pysketcher object is used. Other use case of action is the setting of global parameters like default line color: (drawing_tool.set_linecolor('black')) for example this is stored in the head string thereafter Sketcher Objects Usually starting with the declaration of Pysketcher leaf objects (Geometry object like Line, Circle, Rectangle...) May be aggregated using the composition object Composition can be made of composition object (recursive behaviour) Grouping leafs and composition will be further used to apply transformation latter on (based on the \"physics\") The example presents three group of objects The body object The plan object The friction main object The plan includes the body The friction includes the plan (that will be able to rotate as a group) and the ground (will stay fixed) Libraries, Construction Variables, Frame head = \"\"\"\\ libraries: [\"from math import tan, radians, sin, cos\",\"from pysketcher import *\"] fontsize: 18 g: 9.81 # constant gravity theta: 30.0 # inclined plane angle L: 10.0 # sketch sizing parameter a: 1.0 # xmin: 0.0 # sketech min Abscissa ymin: -3.0 # sketech min Ordinate rl: 2.0 # rectangle width rL: 1.0 # rectangle length setframe: # sketch setup action: \"drawing_tool.set_coordinate_system(xmin=xmin-L/5, xmax=xmin+1.5*L,ymin=ymin, ymax=ymin+1.5*L,instruction_file='tmp_mpl_friction.py')\" setblackline: # default frame values and actions action: \"drawing_tool.set_linecolor('black')\" B: point(a+L,0) # wall right end A: point(a,tan(radians(theta))*L) # wall left end normal_vec: point(sin(radians(theta)),cos(radians(theta))) # Vector normal to wall tangent_vec: point(cos(radians(theta)),-sin(radians(theta))) # Vector tangent to wall help_line: Line(A,B) # wall line x: a + 3*L/10. y: help_line(x=x) contact: point(x, y) c: contact + rL/2*normal_vec \"\"\" The body object body=\"\"\"\\ rectangle: formula: Rectangle(contact, rl, rL) style: linecolor: blue filled_curves: blue transform: [\"rotate(-theta, contact)\", \"translate(-rl/2*tangent_vec)\"] N: formula: Force(contact - rl*normal_vec, contact, r'$N$', text_pos='start') style: linecolor: black wheel: formula: \"Composition({'outer': rectangle})\" style: shadow: 1 mc: formula: Text(r'$c$', c) body: formula: \"Composition({'wheel': wheel, 'N': N, 'mc': mc})\" style: linecolor: black \"\"\" The plan object plan=\"\"\"\\ mB: formula: Text(r'$B$',B) mA: formula: Text(r'$A$', A) wall: formula: Wall(x=[A[0], B[0]], y=[A[1], B[1]], thickness=-0.25,transparent=False) style: linecolor: black x_const: formula: Line(contact, contact + point(0,4)) style: linestyle: dotted transform: rotate(-theta, contact) x_axis: formula: \"Axis(start=contact+ 2*rl*normal_vec, length=2*rl,label='$x$', rotation_angle=-theta)\" plan: formula: \"Composition({'body': body, 'inclined wall': wall, 'x start': x_const, 'x axis': x_axis, 'mA': mA, 'mB': mB})\" \"\"\" The friction sketch friction=\"\"\"\\ mg: formula: Gravity(c, rl, text='$Mg$') style: linecolor: black angle: formula: \"Arc_wText(r'$<bslash>theta$', center=B, radius=3, start_angle=180-theta, arc_angle=theta, fontsize=fontsize)\" style: linecolor: black linewidth: 1 ground: formula: Line((B[0]-L/10., 0), (B[0]-L/2.,0)) stlye: linecolor: black linestyle: dashed linewidth: 1 friction: formula: \"Composition({'plan': plan, 'ground': ground, 'mg': mg, 'angle': angle})\" \"\"\" Using the parser To parse the above example, the following code do the job. 1. the head must be used first as all the other bits needs one or more variable it defines. 2. After, any other string can be parsed, the order just need to respect precedence (if one object uses another one it must be parsed after) 3. this setting allows naturally a modular definition of sketch objects myfig = {} sketchParse(head,myfig) sketchParse(body,myfig) sketchParse(plan,myfig) sketchParse(friction,myfig) \"friction\" sketch hierarchy","title":"Definition"},{"location":"sketcher/#a-language-to-describe-a-sketch","text":"Pysketcher initial version HPL Pysketcher enable sketch definition in python. HPL is showing the hierachical nature of sketches. This is implemented via the Composition function. One can further grasp this using the graphviz_dot function applied to discover the composition herarchy implemented as a graphviz image see The hierarchy of the \"friction\" main object at the end of this page. Due to the hierarchical nature of sketches, it is quite straightforward to think about using yaml as the syntax for defining a sketch. Benefits are the following: Leaner sketch writing as only data relevant to the context needs to be defined A more straightforward reading for the same reason A more robust sketch definition The same set of rules is applied to generate a sketch No further python idiom is be intermingled as opposed to the case of python defined sketches Of course, data defined versus program defined there is no winner, it's just a matter of context","title":"A language to describe a sketch"},{"location":"sketcher/#example","text":"This example provides the yaml content to define the Dry Friction case","title":"Example"},{"location":"sketcher/#the-final-sketch","text":"An inclined plan (the A-B edge) supports a blue rectangle which is dragged down by gravity. The plan makes an angle \\theta \\theta with the ground level. Sketch implementation notebook includes a controller enabling the \\theta \\theta angle to change. The whole plan, including the body, can rotate arround point B.","title":"The final sketch"},{"location":"sketcher/#support-files","text":"The example we are developing now is based upon the \"Dry Friction mockup\" notebook the rendered html version of the notbook can be viewed here the notebook can be download here","title":"Support files"},{"location":"sketcher/#the-yaml-definition","text":"Sketcher language is defined as a yaml compliant file or string. The yaml file is a dictionnary of \"objects\". Objects can be regular python objects or sketcher objects. A skertcher object is composed as follow: a formula : it's a leaf object, like Rectangle, Circle, Line etc or a composition a style list : line or fill colors, line stroke... declared as a yaml hierarchy a transformation list : the defined object can be transformed using sketcher transformation: translation, rotation... As a general rule, a new object suppose all parameters to be defined before they are used to construct it. For example, you can create a circle if the center and the radius have been defined earlier in the file. The general layout of a sketcher file is as follow: Libraries, Construction Variables, Frame declaration of the libraries used by the objects further declared: at least pysketcher is mandatory various global variable which encompass the \"Construction\" variables which define the object main physical dimensions, positions... some \"actions\" corresponding to executable python sentences One mandatory action is the setting of the drawing frame (drawing_tool.set_coordinate_system): it must be declared before any other pysketcher object is used. Other use case of action is the setting of global parameters like default line color: (drawing_tool.set_linecolor('black')) for example this is stored in the head string thereafter Sketcher Objects Usually starting with the declaration of Pysketcher leaf objects (Geometry object like Line, Circle, Rectangle...) May be aggregated using the composition object Composition can be made of composition object (recursive behaviour) Grouping leafs and composition will be further used to apply transformation latter on (based on the \"physics\") The example presents three group of objects The body object The plan object The friction main object The plan includes the body The friction includes the plan (that will be able to rotate as a group) and the ground (will stay fixed)","title":"The yaml definition"},{"location":"sketcher/#libraries-construction-variables-frame","text":"head = \"\"\"\\ libraries: [\"from math import tan, radians, sin, cos\",\"from pysketcher import *\"] fontsize: 18 g: 9.81 # constant gravity theta: 30.0 # inclined plane angle L: 10.0 # sketch sizing parameter a: 1.0 # xmin: 0.0 # sketech min Abscissa ymin: -3.0 # sketech min Ordinate rl: 2.0 # rectangle width rL: 1.0 # rectangle length setframe: # sketch setup action: \"drawing_tool.set_coordinate_system(xmin=xmin-L/5, xmax=xmin+1.5*L,ymin=ymin, ymax=ymin+1.5*L,instruction_file='tmp_mpl_friction.py')\" setblackline: # default frame values and actions action: \"drawing_tool.set_linecolor('black')\" B: point(a+L,0) # wall right end A: point(a,tan(radians(theta))*L) # wall left end normal_vec: point(sin(radians(theta)),cos(radians(theta))) # Vector normal to wall tangent_vec: point(cos(radians(theta)),-sin(radians(theta))) # Vector tangent to wall help_line: Line(A,B) # wall line x: a + 3*L/10. y: help_line(x=x) contact: point(x, y) c: contact + rL/2*normal_vec \"\"\"","title":"Libraries, Construction Variables, Frame"},{"location":"sketcher/#the-body-object","text":"body=\"\"\"\\ rectangle: formula: Rectangle(contact, rl, rL) style: linecolor: blue filled_curves: blue transform: [\"rotate(-theta, contact)\", \"translate(-rl/2*tangent_vec)\"] N: formula: Force(contact - rl*normal_vec, contact, r'$N$', text_pos='start') style: linecolor: black wheel: formula: \"Composition({'outer': rectangle})\" style: shadow: 1 mc: formula: Text(r'$c$', c) body: formula: \"Composition({'wheel': wheel, 'N': N, 'mc': mc})\" style: linecolor: black \"\"\"","title":"The body object"},{"location":"sketcher/#the-plan-object","text":"plan=\"\"\"\\ mB: formula: Text(r'$B$',B) mA: formula: Text(r'$A$', A) wall: formula: Wall(x=[A[0], B[0]], y=[A[1], B[1]], thickness=-0.25,transparent=False) style: linecolor: black x_const: formula: Line(contact, contact + point(0,4)) style: linestyle: dotted transform: rotate(-theta, contact) x_axis: formula: \"Axis(start=contact+ 2*rl*normal_vec, length=2*rl,label='$x$', rotation_angle=-theta)\" plan: formula: \"Composition({'body': body, 'inclined wall': wall, 'x start': x_const, 'x axis': x_axis, 'mA': mA, 'mB': mB})\" \"\"\"","title":"The plan object"},{"location":"sketcher/#the-friction-sketch","text":"friction=\"\"\"\\ mg: formula: Gravity(c, rl, text='$Mg$') style: linecolor: black angle: formula: \"Arc_wText(r'$<bslash>theta$', center=B, radius=3, start_angle=180-theta, arc_angle=theta, fontsize=fontsize)\" style: linecolor: black linewidth: 1 ground: formula: Line((B[0]-L/10., 0), (B[0]-L/2.,0)) stlye: linecolor: black linestyle: dashed linewidth: 1 friction: formula: \"Composition({'plan': plan, 'ground': ground, 'mg': mg, 'angle': angle})\" \"\"\"","title":"The friction sketch"},{"location":"sketcher/#using-the-parser","text":"To parse the above example, the following code do the job. 1. the head must be used first as all the other bits needs one or more variable it defines. 2. After, any other string can be parsed, the order just need to respect precedence (if one object uses another one it must be parsed after) 3. this setting allows naturally a modular definition of sketch objects myfig = {} sketchParse(head,myfig) sketchParse(body,myfig) sketchParse(plan,myfig) sketchParse(friction,myfig)","title":"Using the parser"},{"location":"sketcher/#friction-sketch-hierarchy","text":"","title":"\"friction\" sketch hierarchy"}]}